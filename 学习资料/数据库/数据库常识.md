# sql性能增强


## 关系型数据库与非关系数据库的区别
关系型数据库  
一个结构化的数据库，创建在关系模型（二维表格模型）基础上，一般面向于记录。  
非关系型数据库  
意思是“不仅仅是 SQL”，是非关系型数据库的总称。  
### 数据存储方式不同
关系型数据天然就是表格式的，因此存储在数据表的行和列中。  
非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档、键值对或者图结构。
### 扩展方式不同
为了支持更多并发量，SQL(关系)数据库是纵向扩展，也就是说提高处理能力，使用速度更快速的计算机，这样处理相同的数据集就更快了。
而NoSQL数据库是横向扩展的。因为非关系型数据存储天然就是分布式的，NoSQL数据库的扩展可以通过给资源池添加更多普通的数据库服务器(节点)来分担负载。
### 对事务性的支持不同
数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的SQL数据库从性能和稳定性方面考虑是你的最佳选择。SQL数据库支持对事务原子性细粒度控制，并且易于回滚事务。
NoSQL数据库也可以使用事务操作，但稳定性方面没法和关系型数据库比较，所以它们真正闪亮的价值是在操作的扩展性和大数据量处理方面。

## 分库分表
### 只分库不分表
分库
数据库读写QPS，导致数据库连接不足
通过增加数据实例的方式来提供更多的可用数据库连接，从而提升系统的并发度
### 不分库只分表
分表
当你的单表数据量非常的大，并发不高，数据库连接还够，存储查询性能遇到了瓶颈
通过将数据拆分到多个表中，从而提高查询数据
#### 应用
1.对运单表进行分表(运输企业(卖家id)向司机(卖家id)提供订单)，用买家id做分表字段，可用有效避免分表产生的数据倾斜(卖家的运单多少不均衡，按照卖家id分表会导致某些表数据过多)
2.分表查询
分表路由设定规则(分表不是给每一个份表字段单独分一个独立的表)，固定的分成1024张表，通过分表字段(如果不是id，用hashcode)对1024进行取模，结果是0000~1023，把数据存储到对应的表中即可。
1. 买家查询自己的订单
通过买家id查询，对应的表里自己的订单。
2. 卖家查询自己的订单
有卖家id，通过bin log或者flink等实时链路同步一张卖家维度的分表，这张表专门用来查用卖家id查询。
3. 管理员查询订单
通过订单号查询，在生成订单号时把分表结果编码到订单号里面去，吧买家id的取模放到订单编号里， 查询时在编码中解析出订单即可。
### 既分库又分表
当你的单表数据量非常的大，并发高，数据库连接不够，存储查询性能遇到了瓶颈、


## 读写分离


# 索引的理解

索引将字段从表中所有data page(分页数据4k)抽出来形成data page(4k)[形成一个索引文件(数据越多，空间成本越高)]。
通过内存的B+树(二叉数)筛选区间，来进行查询访问磁盘上存储的索引。
有索引的表，会导致维护成本变高，空间成本变低。
索引会增加表增删改的难度、速度变慢，仅增加查询数据。

## B+树

# 大量写入优化

# 数据在磁盘和内存体积不一样，硬盘读取慢，用缓存处理
数据在磁盘中不存在指针，内存中数据存在指针。

# MySQL范式
1. 第一范式
第一范式主要确保数据表中每个字段的值都具有原子性，也就是说表中每个字段不能再被拆分。这个范式一定需要遵守。

例如某个字段user_info，包含了家庭住址，邮箱，电话，这显然是不可以的，需要将user_info拆分成对应的三个字段。

但是原子性事实上是主观的，例如姓名name可能有firstName，lastName，那是否需要拆分，再例如是否需要将地址拆分成省份，区域等，这取决于应用程序是否需要查询到哪种粒度。

2. 第二范式
在满足第一范式的基础上，还要满足数据库表中的每一条数据，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。

举例1：

成绩表（学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以（学号，课程号）和成绩就是完全依赖关系。

举例2：

比赛表，里面包含了球员编号，姓名，年龄，比赛编号，比赛时间，比赛场地等属性，由于单单球员编号和比赛编号都无法确定唯一一条数据，因此需要将球员编号和比赛编号联合作为主键：

(球员编号，比赛编号) --> (姓名，年龄，比赛时间，比赛场地，得分)
1
但是这个表并不满足第二范式，因为数据表中的字段并不满足完全依赖主键的条件：

(球员编号)  --> (姓名，年龄)

(比赛编号)  --> (比赛时间，比赛场地)

不满足第二范式的问题：

数据冗余：如果一个球员参加了n场比赛，那么球员的姓名和年龄就重复了n次，一个比赛也有可能有m个球员参加，那比赛的时间和地点就重复了m次。
插入异常：如果我们想要添加一场新的比赛，但是这时球员还没有确定，那么就无法插入。
删除异常：如果我们想要删除某个球员编号，会将比赛信息删除掉。
更新异常：如果我们想要调整某个比赛的时间，那么数据库表中所有关于这个比赛的时间都需要进行调整，否则会出现一场比赛时间不同的情况。
因此为了避免上面的问题，我们可以将上面球员比赛表设计成三张表，这样每张表都符合了第二范式

球员表：球员编号，姓名，年龄等

比赛表：比赛编号，比赛场地，比赛时间等

球员比赛关系表：球员编号，比赛编号，得分等

3. 第三范式
在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖于其他非主键字段字段。（即不能存在非主属性A依赖非主属性B，非主属性B依赖于主键C的情况），通俗来说，该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。

举例：

员工信息表：员工编号，姓名，部门编号，部门名称。

上面的员工信息表是符合第二范式的，因为姓名，部门编号，部门名称都完全依赖员工编号这个主键，但是并不符合第三范式，因为有非主键字段 部门名称 依赖于非主键字段 部门编号。因此需要将部门编号，部门名称再抽取成一张表。

# 外键


# 数据读取慢，至今未解决的本质原因（至今未解决）：
1. 冯诺依曼体系的硬件 (物理限制)
2. 以太网 tcp/ip的网络  (网络不稳定)
应用缓存加快IO读取操作。


数据一致性