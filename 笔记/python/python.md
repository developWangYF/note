# 运行Python脚本时生成的__pycache__文件夹（）和java文件预编译生成的java.c文件很像
· 前言
用python编写好一个工程，在第一次运行后，总会发现工程根目录下生成了一个__pycache__文件夹，里面是和py文件同名的各种 *.pyc 或者 *.pyo 文件。



先大概了解一下python基本运行机制。Python程序运行时不需要编译成二进制代码，而直接从源码运行程序，简单来说是，Python解释器将源码转换为字节码，然后再由解释器来执行这些字节码。

解释器的具体工作：

1 完成模块的加载和链接；

2 将源代码编译为PyCodeObject对象(即字节码)，写入内存中，供CPU读取；

3 从内存中读取并执行，结束后将PyCodeObject写回硬盘当中，也就是复制到.pyc或.pyo文件中，以保存当前目录下所有脚本的字节码文件；

* 之后若再次执行该脚本，它先检查【本地是否有上述字节码文件】和【该字节码文件的修改时间是否与其脚本一致】。是就直接执行，否则重复上述步骤。



以下参考自stackoverflow上的一个回答。


· 为什么会出现__pycache__文件夹？
python解释器会将 *.py 脚本文件进行编译，并将编译结果保存到__pycache__目录中。


下次再执行工程时，若解释器发现这个 *.py 脚本没有修改过，就会跳过编译这一步，直接运行以前生成的保存在 __pycache__文件夹里的 *.pyc 文件。

这样工程较大时就可以大大缩短项目运行前的准备时间；如果你只需执行一个小工程，没关系 忽略这个文件夹就行。



· 什么时候会出现__pycache__文件夹？
工程目录下有__main__.py文件，和其他将要调用的模块时。如果只有当前运行的脚本 "__main__"，则不会生成 __pycache__ 的文件。



· 如何使__pycache__文件夹不出现？
单次: 运行脚本时添加 -B 参数

python -B foo.py

永久: 设置环境变量 PYTHONDONTWRITEBYTECODE=1


   附：该文件夹出现在Python3.2及其后的版本中，Python2下的编译文件和源文件放同目录。

# 当你要导入某个模块，但又不想改模块的部分代码被直接执行，那就可以这一部分代码放在“if __name__=='__main__':”内部。
导入库模块时，会执行if __name__=='__main__':之上全部执行，之下不会被执行，只有独立执行本文件时才会执行。